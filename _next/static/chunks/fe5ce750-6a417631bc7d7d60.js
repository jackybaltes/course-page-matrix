"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[53],{94161:function(e,t,i){var s,r=i(31180).Buffer,o=i(53058);Object.defineProperty(t,"__esModule",{value:!0}),t.IncomingRoomKeyRequest=t.CryptoEvent=t.Crypto=void 0,t.fixBackupKey=et,t.isCryptoAvailable=function(){return!!globalThis.Olm},t.verificationMethods=void 0;var n=o(i(13102)),a=o(i(6691)),c=i(2461),g=i(15748),l=i(92807),d=i(34002),h=i(10845),u=z(i(14995)),y=i(97043),v=i(5382),p=z(i(22079)),f=i(807),m=i(84018),S=i(72424),k=i(75661),w=i(20900),I=i(87786),D=i(56674),C=i(71418),R=i(53978),b=i(41806),K=i(78017),E=i(14431),T=i(46368),_=i(60747),O=i(74460),q=i(54410),A=i(70152),M=i(80323),U=i(29197),L=i(74130),V=i(39325),B=i(32950),F=i(61225),P=i(44441),N=i(19389),j=i(44480),x=i(98466),G=i(68995),W=i(84881),H=i(498),Y=i(98870);function Q(e){if("function"!=typeof WeakMap)return null;var t=new WeakMap,i=new WeakMap;return(Q=function(e){return e?i:t})(e)}function z(e,t){if(!t&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var i=Q(t);if(i&&i.has(e))return i.get(e);var s={__proto__:null},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if("default"!==o&&Object.prototype.hasOwnProperty.call(e,o)){var n=r?Object.getOwnPropertyDescriptor(e,o):null;n&&(n.get||n.set)?Object.defineProperty(s,o,n):s[o]=e[o]}return s.default=e,i&&i.set(e,s),s}function J(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),i.push.apply(i,s)}return i}let X=v.DeviceInfo.DeviceVerification,Z={[D.ReciprocateQRCode.NAME]:D.ReciprocateQRCode,[C.SAS.NAME]:C.SAS,[D.SHOW_QR_CODE_METHOD]:_.IllegalMethod,[D.SCAN_QR_CODE_METHOD]:_.IllegalMethod};t.verificationMethods={RECIPROCATE_QR_CODE:D.ReciprocateQRCode.NAME,SAS:C.SAS.NAME};let $=t.CryptoEvent=((s={}).DeviceVerificationChanged="deviceVerificationChanged",s.UserTrustStatusChanged="userTrustStatusChanged",s.UserCrossSigningUpdated="userCrossSigningUpdated",s.RoomKeyRequest="crypto.roomKeyRequest",s.RoomKeyRequestCancellation="crypto.roomKeyRequestCancellation",s.KeyBackupStatus="crypto.keyBackupStatus",s.KeyBackupFailed="crypto.keyBackupFailed",s.KeyBackupSessionsRemaining="crypto.keyBackupSessionsRemaining",s.KeyBackupDecryptionKeyCached="crypto.keyBackupDecryptionKeyCached",s.KeySignatureUploadFailure="crypto.keySignatureUploadFailure",s.VerificationRequest="crypto.verification.request",s.VerificationRequestReceived="crypto.verificationRequestReceived",s.Warning="crypto.warning",s.WillUpdateDevices="crypto.willUpdateDevices",s.DevicesUpdated="crypto.devicesUpdated",s.KeysChanged="crossSigning.keysChanged",s.LegacyCryptoStoreMigrationProgress="crypto.legacyCryptoStoreMigrationProgress",s);class ee extends P.TypedEventEmitter{static getOlmVersion(){return h.OlmDevice.getOlmVersion()}async init(){let{exportedOlmDevice:e,pickleKey:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};d.logger.log("Crypto: initialising Olm..."),await i.g.Olm.init(),d.logger.log(e?"Crypto: initialising Olm device from exported device...":"Crypto: initialising Olm device..."),await this.olmDevice.init({fromExportedDevice:e,pickleKey:t}),d.logger.log("Crypto: loading device list..."),await this.deviceList.load(),this.deviceKeys["ed25519:"+this.deviceId]=this.olmDevice.deviceEd25519Key,this.deviceKeys["curve25519:"+this.deviceId]=this.olmDevice.deviceCurve25519Key,d.logger.log("Crypto: fetching own devices...");let s=this.deviceList.getRawStoredDevicesForUser(this.userId);if(s||(s={}),!s[this.deviceId]){d.logger.log("Crypto: adding this device to the store...");let e={keys:this.deviceKeys,algorithms:this.supportedAlgorithms,verified:X.VERIFIED,known:!0};s[this.deviceId]=e,this.deviceList.storeDevicesForUser(this.userId,s),this.deviceList.saveIfDirty()}await this.cryptoStore.doTxn("readonly",[I.IndexedDBCryptoStore.STORE_ACCOUNT],e=>{this.cryptoStore.getCrossSigningKeys(e,e=>{e&&0!==Object.keys(e).length&&(d.logger.log("Loaded cross-signing public keys from crypto store"),this.crossSigningInfo.setKeys(e))})}),this.deviceList.startTrackingDeviceList(this.userId),d.logger.debug("Crypto: initialising roomlist..."),await this.roomList.init(),d.logger.log("Crypto: checking for key backup..."),this.backupManager.checkAndStart()}getVersion(){let e=ee.getOlmVersion();return"Olm ".concat(e[0],".").concat(e[1],".").concat(e[2])}getTrustCrossSignedDevices(){return this.trustCrossSignedDevices}getCryptoTrustCrossSignedDevices(){return this.trustCrossSignedDevices}setTrustCrossSignedDevices(e){for(let t of(this.trustCrossSignedDevices=e,this.deviceList.getKnownUserIds()))for(let e of Object.keys(this.deviceList.getRawStoredDevicesForUser(t))){let i=this.checkDeviceTrust(t,e);if(!i.isLocallyVerified()&&i.isCrossSigningVerified()){let i=this.deviceList.getStoredDevice(t,e);this.emit($.DeviceVerificationChanged,t,e,i)}}}setCryptoTrustCrossSignedDevices(e){this.setTrustCrossSignedDevices(e)}async createRecoveryKeyFromPassphrase(e){let t=new i.g.Olm.PkDecryption;try{if(e){let i=await (0,R.keyFromPassphrase)(e);t.init_with_private_key(i.key);let s=t.get_private_key();return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:i.iterations,salt:i.salt}},privateKey:s,encodedPrivateKey:(0,b.encodeRecoveryKey)(s)}}{t.generate_key();let e=t.get_private_key();return{privateKey:e,encodedPrivateKey:(0,b.encodeRecoveryKey)(e)}}}finally{null==t||t.free()}}async userHasCrossSigningKeys(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.userId;return await this.downloadKeys([e]),null!==this.deviceList.getStoredCrossSigningForUser(e)}async isCrossSigningReady(){let e=this.crossSigningInfo.getId(),t=await this.crossSigningInfo.isStoredInKeyCache()||await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage);return!!(e&&t)}async isSecretStorageReady(){let e=await this.secretStorage.hasKey(),t=await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage),i=!this.backupManager.getKeyBackupEnabled()||await this.baseApis.isKeyBackupKeyStored();return!!(e&&t&&i)}async getCrossSigningStatus(){var e,t,i;let s=!!this.crossSigningInfo.getId(),r=!!await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage),o=this.crossSigningInfo.getCacheCallbacks();return{publicKeysOnDevice:s,privateKeysInSecretStorage:r,privateKeysCachedLocally:{masterKey:!!await (null===(e=o.getCrossSigningKeyCache)||void 0===e?void 0:e.call(o,"master")),selfSigningKey:!!await (null===(t=o.getCrossSigningKeyCache)||void 0===t?void 0:t.call(o,"self_signing")),userSigningKey:!!await (null===(i=o.getCrossSigningKeyCache)||void 0===i?void 0:i.call(o,"user_signing"))}}}async bootstrapCrossSigning(){let{authUploadDeviceSigningKeys:e,setupNewCrossSigning:t}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};d.logger.log("Bootstrapping cross-signing");let i=this.baseApis.cryptoCallbacks,s=new m.EncryptionSetupBuilder(this.baseApis.store.accountData,i),r=new f.CrossSigningInfo(this.userId,s.crossSigningCallbacks,s.crossSigningCallbacks),o=async()=>{r.resetKeys(),await this.signObject(r.keys.master),s.addCrossSigningKeys(e,r.keys);let t=this.deviceList.getStoredDevice(this.userId,this.deviceId),i=await r.signDevice(this.userId,t);s.addKeySignature(this.userId,this.deviceId,i),this.backupManager.backupInfo&&(await r.signObject(this.backupManager.backupInfo.auth_data,"master"),s.addSessionBackup(this.backupManager.backupInfo))},n=this.crossSigningInfo.getId(),a=await this.crossSigningInfo.isStoredInKeyCache(),c=await this.crossSigningInfo.isStoredInSecretStorage(this.secretStorage),g=a||c;d.logger.log({setupNewCrossSigning:t,publicKeysOnDevice:n,privateKeysInCache:a,privateKeysInStorage:c,privateKeysExistSomewhere:g}),!g||t?(d.logger.log("Cross-signing private keys not found locally or in secret storage, creating new keys"),await o()):n&&a?d.logger.log("Cross-signing public keys trusted and private keys found locally"):c&&(d.logger.log("Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"),await this.checkOwnCrossSigningTrust({allowPrivateKeyRequests:!0}));let l=s.crossSigningCallbacks.privateKeys;if(l.size&&!this.baseApis.cryptoCallbacks.saveCrossSigningKeys){let e=new x.ServerSideSecretStorageImpl(s.accountDataClientAdapter,s.ssssCryptoCallbacks);await e.hasKey()&&(d.logger.log("Storing new cross-signing private keys in secret storage"),await f.CrossSigningInfo.storeInSecretStorage(l,e))}let h=s.buildOperation();await h.apply(this),await s.persist(this),d.logger.log("Cross-signing ready")}async bootstrapSecretStorage(){let{createSecretStorageKey:e=async()=>({}),keyBackupInfo:t,setupNewKeyBackup:i,setupNewSecretStorage:s,getKeyBackupPassphrase:r}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};d.logger.log("Bootstrapping Secure Secret Storage");let o=this.baseApis.cryptoCallbacks,n=new m.EncryptionSetupBuilder(this.baseApis.store.accountData,o),a=new x.ServerSideSecretStorageImpl(n.accountDataClientAdapter,n.ssssCryptoCallbacks),c=null,g=async e=>{let{keyId:t,keyInfo:i}=await a.addKey(x.SECRET_STORAGE_ALGORITHM_V1_AES,e);return n.ssssCryptoCallbacks.addPrivateKey(t,i,e.key),await a.setDefaultKeyId(t),t},l=async(e,t)=>{if(!t.mac){var i,s;let r=await (null===(i=(s=this.baseApis.cryptoCallbacks).getSecretStorageKey)||void 0===i?void 0:i.call(s,{keys:{[e]:t}},""));if(r){let i=r[1];n.ssssCryptoCallbacks.addPrivateKey(e,t,i);let{iv:s,mac:o}=await (0,q.calculateKeyCheck)(i);t.iv=s,t.mac=o,await n.setAccountData("m.secret_storage.key.".concat(e),t)}}},h=async e=>{if(this.crossSigningInfo.getId()&&await this.crossSigningInfo.isStoredInKeyCache("master"))try{d.logger.log("Adding cross-signing signature to key backup"),await this.crossSigningInfo.signObject(e,"master")}catch(e){d.logger.error("Signing key backup with cross-signing keys failed",e)}else d.logger.warn("Cross-signing keys not available, skipping signature on key backup")},[u,y]=await this.secretStorage.getKey()||[null,null],v=!s&&y&&y.algorithm===x.SECRET_STORAGE_ALGORITHM_V1_AES;if(d.logger.log({keyBackupInfo:t,setupNewKeyBackup:i,setupNewSecretStorage:s,storageExists:v,oldKeyInfo:y}),v||t){if(!v&&t){d.logger.log("Secret storage does not exist, using key backup key");let e=await this.getSessionBackupPrivateKey()||await (null==r?void 0:r()),i={key:e};t.auth_data.private_key_salt&&t.auth_data.private_key_iterations&&(i.passphrase={algorithm:"m.pbkdf2",iterations:t.auth_data.private_key_iterations,salt:t.auth_data.private_key_salt,bits:256}),c=await g(i),await a.store("m.megolm_backup.v1",(0,Y.encodeBase64)(e),[c]),await h(t.auth_data),n.addSessionBackup(t)}else d.logger.log("Secret storage exists"),y&&y.algorithm===x.SECRET_STORAGE_ALGORITHM_V1_AES&&await l(u,y)}else{d.logger.log("Secret storage does not exist, creating new storage key");let{keyInfo:t,privateKey:i}=await e();c=await g({passphrase:null==t?void 0:t.passphrase,key:i,name:null==t?void 0:t.name})}if(!this.baseApis.cryptoCallbacks.saveCrossSigningKeys&&await this.isCrossSigningReady()&&(c||!await this.crossSigningInfo.isStoredInSecretStorage(a))){d.logger.log("Copying cross-signing private keys from cache to secret storage");let e=await this.crossSigningInfo.getCrossSigningKeysFromCache();await f.CrossSigningInfo.storeInSecretStorage(e,a)}if(i&&!t){d.logger.log("Creating new message key backup version");let e=await this.baseApis.prepareKeyBackupVersion(null,{secureSecretStorage:!1}),t=(0,b.decodeRecoveryKey)(e.recovery_key);await a.store("m.megolm_backup.v1",(0,Y.encodeBase64)(t));let i={algorithm:e.algorithm,auth_data:e.auth_data};await h(i.auth_data),await this.signObject(i.auth_data),n.addSessionBackup(i)}let p=await a.get("m.megolm_backup.v1");if(p){d.logger.info("Got session backup key from secret storage: caching");let e=et(p);if(e){let t=c||u;await a.store("m.megolm_backup.v1",e,t?[t]:null)}let t=new Uint8Array((0,Y.decodeBase64)(e||p));n.addSessionBackupPrivateKeyToCache(t)}else if(this.backupManager.getKeyBackupEnabled()){let e=await this.getSessionBackupPrivateKey()||await (null==r?void 0:r());if(!e){d.logger.error("Key backup is enabled but couldn't get key backup key!");return}d.logger.info("Got session backup key from cache/user that wasn't in SSSS: saving to SSSS"),await a.store("m.megolm_backup.v1",(0,Y.encodeBase64)(e))}let S=n.buildOperation();await S.apply(this),await n.persist(this),d.logger.log("Secure Secret Storage ready")}async resetKeyBackup(){await this.backupManager.deleteAllKeyBackupVersions();let e=await this.backupManager.prepareKeyBackupVersion();await this.signObject(e.auth_data);let{version:t}=await this.baseApis.http.authedRequest(H.Method.Post,"/room_keys/version",void 0,e,{prefix:H.ClientPrefix.V3});d.logger.log("Created backup version ".concat(t));let i=e.privateKey;await this.secretStorage.store("m.megolm_backup.v1",(0,Y.encodeBase64)(i)),await this.storeSessionBackupPrivateKey(i),await this.backupManager.checkAndStart(),await this.backupManager.scheduleAllGroupSessionsForBackup()}async deleteKeyBackupVersion(e){await this.backupManager.deleteKeyBackupVersion(e)}addSecretStorageKey(e,t,i){return this.secretStorage.addKey(e,t,i)}hasSecretStorageKey(e){return this.secretStorage.hasKey(e)}getSecretStorageKey(e){return this.secretStorage.getKey(e)}storeSecret(e,t,i){return this.secretStorage.store(e,t,i)}getSecret(e){return this.secretStorage.get(e)}isSecretStored(e){return this.secretStorage.isStored(e)}requestSecret(e,t){return t||(t=Object.keys(this.deviceList.getRawStoredDevicesForUser(this.userId))),this.secretStorage.request(e,t)}getDefaultSecretStorageKeyId(){return this.secretStorage.getDefaultKeyId()}setDefaultSecretStorageKeyId(e){return this.secretStorage.setDefaultKeyId(e)}checkSecretStorageKey(e,t){return this.secretStorage.checkKey(e,t)}checkSecretStoragePrivateKey(e,t){let s=null;try{return(s=new i.g.Olm.PkDecryption).init_with_private_key(e)===t}finally{var r;null===(r=s)||void 0===r||r.free()}}async getSessionBackupPrivateKey(){let e=await new Promise(e=>{this.cryptoStore.doTxn("readonly",[I.IndexedDBCryptoStore.STORE_ACCOUNT],t=>{this.cryptoStore.getSecretStorePrivateKey(t,e,"m.megolm_backup.v1")})}),t=null;if("string"==typeof e&&(t=new Uint8Array((0,Y.decodeBase64)(et(e)||e)),await this.storeSessionBackupPrivateKey(t)),e&&"object"==typeof e&&"ciphertext"in e){let i=r.from(this.olmDevice.pickleKey),s=await (0,q.decryptAES)(e,i,"m.megolm_backup.v1");t=(0,Y.decodeBase64)(s)}return t}async storeSessionBackupPrivateKey(e,t){if(!(e instanceof Uint8Array))throw Error("storeSessionBackupPrivateKey expects Uint8Array, got ".concat(e));let i=r.from(this.olmDevice.pickleKey),s=await (0,q.encryptAES)((0,Y.encodeBase64)(e),i,"m.megolm_backup.v1");return this.cryptoStore.doTxn("readwrite",[I.IndexedDBCryptoStore.STORE_ACCOUNT],e=>{this.cryptoStore.storeSecretStorePrivateKey(e,"m.megolm_backup.v1",s)})}async getActiveSessionBackupVersion(){if(this.backupManager.getKeyBackupEnabled()){var e;return null!==(e=this.backupManager.version)&&void 0!==e?e:null}return null}async isKeyBackupTrusted(e){let t=await this.backupManager.isKeyBackupTrusted(e);return(0,M.backupTrustInfoFromLegacyTrustInfo)(t)}async checkKeyBackupAndEnable(){let e=await this.backupManager.checkKeyBackup();return e&&e.backupInfo?{backupInfo:e.backupInfo,trustInfo:(0,M.backupTrustInfoFromLegacyTrustInfo)(e.trustInfo)}:null}checkCrossSigningPrivateKey(e,t){let s=null;try{return(s=new i.g.Olm.PkSigning).init_with_seed(e)===t}finally{var r;null===(r=s)||void 0===r||r.free()}}async afterCrossSigningLocalKeyChange(){d.logger.info("Starting cross-signing key change post-processing");let e=this.deviceList.getStoredDevice(this.userId,this.deviceId),t=await this.crossSigningInfo.signDevice(this.userId,e);d.logger.info("Starting background key sig upload for ".concat(this.deviceId));let i=e=>{let{shouldEmit:s=!1}=e;return this.baseApis.uploadKeySignatures({[this.userId]:{[this.deviceId]:t}}).then(e=>{let{failures:t}=e||{};if(Object.keys(t||[]).length>0)throw s&&this.baseApis.emit($.KeySignatureUploadFailure,t,"afterCrossSigningLocalKeyChange",i),new O.KeySignatureUploadError("Key upload failed",{failures:t});d.logger.info("Finished background key sig upload for ".concat(this.deviceId))}).catch(e=>{d.logger.error("Error during background key sig upload for ".concat(this.deviceId),e)})};i({shouldEmit:!0});let s=this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;if(s){d.logger.info("Starting device verification upgrade");let e={};for(let[t,i]of Object.entries(this.deviceList.crossSigningInfo)){let s=await this.checkForDeviceVerificationUpgrade(t,f.CrossSigningInfo.fromStorage(i,t));s&&(e[t]=s)}if(Object.keys(e).length>0){d.logger.info("Found ".concat(Object.keys(e).length," verif users to upgrade"));try{let t=await s({users:e});if(t)for(let i of t)i in e&&await this.baseApis.setDeviceVerified(i,e[i].crossSigningInfo.getId())}catch(e){d.logger.log("shouldUpgradeDeviceVerifications threw an error: not upgrading",e)}}d.logger.info("Finished device verification upgrade")}d.logger.info("Finished cross-signing key change post-processing")}async checkForDeviceVerificationUpgrade(e,t){let i=this.crossSigningInfo.checkUserTrust(t);if(t.firstUse&&!i.isVerified()){let i=this.deviceList.getRawStoredDevicesForUser(e),s=await this.checkForValidDeviceSignature(e,t.keys.master,i);if(s.length)return{devices:s.map(e=>v.DeviceInfo.fromStorage(i[e],e)),crossSigningInfo:t}}}async checkForValidDeviceSignature(e,t,i){let s=[];if(i&&t.signatures&&t.signatures[e])for(let r of Object.keys(t.signatures[e])){let[,o]=r.split(":",2);if(o in i&&i[o].verified===X.VERIFIED)try{await u.verifySignature(this.olmDevice,t,e,o,i[o].keys[r]),s.push(o)}catch(e){}}return s}getCrossSigningKeyId(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:k.CrossSigningKey.Master;return Promise.resolve(this.getCrossSigningId(e))}getCrossSigningId(e){return this.crossSigningInfo.getId(e)}getStoredCrossSigningForUser(e){return this.deviceList.getStoredCrossSigningForUser(e)}checkUserTrust(e){let t=this.deviceList.getStoredCrossSigningForUser(e);return t?this.crossSigningInfo.checkUserTrust(t):new f.UserTrustLevel(!1,!1,!1)}async getUserVerificationStatus(e){return this.checkUserTrust(e)}async getDeviceVerificationStatus(e,t){let i=this.deviceList.getStoredDevice(e,t);return i?this.checkDeviceInfoTrust(e,i):null}checkDeviceTrust(e,t){let i=this.deviceList.getStoredDevice(e,t);return this.checkDeviceInfoTrust(e,i)}checkDeviceInfoTrust(e,t){let i=!!(null!=t&&t.isVerified()),s=this.deviceList.getStoredCrossSigningForUser(e);if(!t||!s)return new f.DeviceTrustLevel(!1,!1,i,!1);{let r=this.trustCrossSignedDevices||e===this.userId;return this.crossSigningInfo.checkDeviceTrust(s,t,i,r)}}checkIfOwnDeviceCrossSigned(e){var t;let i=this.deviceList.getStoredDevice(this.userId,e);if(!i)return!1;let s=this.deviceList.getStoredCrossSigningForUser(this.userId);return null!==(t=null==s?void 0:s.checkDeviceTrust(s,i,!1,!0).isCrossSigningVerified())&&void 0!==t&&t}async checkOwnCrossSigningTrust(){var e,t,i;let{allowPrivateKeyRequests:s=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=this.userId;await this.downloadKeys([this.userId]);let o=await this.crossSigningInfo.getCrossSigningKeysFromCache(),n=this.deviceList.getStoredCrossSigningForUser(r);if(!n){d.logger.error("Got cross-signing update event for user "+r+" but no new cross-signing information found!");return}let a=n.getId(),c=this.crossSigningInfo.getId()!==a,g=n.getId()&&!o.has("master");if(c&&d.logger.info("Got new master public key",a),s&&(c||g)){d.logger.info("Attempting to retrieve cross-signing master private key");let t=null;try{t=(await this.crossSigningInfo.getCrossSigningKey("master",a))[1],d.logger.info("Got cross-signing master private key")}finally{null===(e=t)||void 0===e||e.free()}}let l=this.crossSigningInfo.getId("self_signing"),h=this.crossSigningInfo.getId("user_signing");this.storeTrustedSelfKeys(n.keys);let u=l!==n.getId("self_signing"),y=h!==n.getId("user_signing"),v=n.getId("self_signing")&&!o.has("self_signing"),p=n.getId("user_signing")&&!o.has("user_signing"),f={};if(u&&d.logger.info("Got new self-signing key",n.getId("self_signing")),s&&(u||v)){d.logger.info("Attempting to retrieve cross-signing self-signing private key");let e=null;try{e=(await this.crossSigningInfo.getCrossSigningKey("self_signing",n.getId("self_signing")))[1],d.logger.info("Got cross-signing self-signing private key")}finally{null===(t=e)||void 0===t||t.free()}let i=this.deviceList.getStoredDevice(this.userId,this.deviceId),s=await this.crossSigningInfo.signDevice(this.userId,i);f[this.deviceId]=s}if(y&&d.logger.info("Got new user-signing key",n.getId("user_signing")),s&&(y||p)){d.logger.info("Attempting to retrieve cross-signing user-signing private key");let e=null;try{e=(await this.crossSigningInfo.getCrossSigningKey("user_signing",n.getId("user_signing")))[1],d.logger.info("Got cross-signing user-signing private key")}finally{null===(i=e)||void 0===i||i.free()}}if(c){let e=this.crossSigningInfo.keys.master;await this.signObject(e);let t=e.signatures[this.userId]["ed25519:"+this.deviceId];f[this.crossSigningInfo.getId()]=Object.assign({},e,{signatures:{[this.userId]:{["ed25519:"+this.deviceId]:t}}})}let m=Object.keys(f);if(m.length){let e=t=>{let{shouldEmit:i=!1}=t;return d.logger.info("Starting background key sig upload for ".concat(m)),this.baseApis.uploadKeySignatures({[this.userId]:f}).then(t=>{let{failures:s}=t||{};if(d.logger.info("Finished background key sig upload for ".concat(m)),Object.keys(s||[]).length>0)throw i&&this.baseApis.emit($.KeySignatureUploadFailure,s,"checkOwnCrossSigningTrust",e),new O.KeySignatureUploadError("Key upload failed",{failures:s})}).catch(e=>{d.logger.error("Error during background key sig upload for ".concat(m),e)})};e({shouldEmit:!0})}this.emit($.UserTrustStatusChanged,r,this.checkUserTrust(r)),c&&(this.emit($.KeysChanged,{}),await this.afterCrossSigningLocalKeyChange()),await this.backupManager.checkKeyBackup()}async getBackupDecryptor(e,t){if(!(t instanceof Uint8Array))throw Error("getBackupDecryptor expects Uint8Array");let i=await M.BackupManager.makeAlgorithm(e,async()=>t);return await i.keyMatches(t)?new M.LibOlmBackupDecryptor(i):Promise.reject(new H.MatrixError({errcode:B.MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY}))}importBackedUpRoomKeys(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t.source="backup",this.importRoomKeys(e,t)}async storeTrustedSelfKeys(e){e?this.crossSigningInfo.setKeys(e):this.crossSigningInfo.clearKeys(),await this.cryptoStore.doTxn("readwrite",[I.IndexedDBCryptoStore.STORE_ACCOUNT],e=>{this.cryptoStore.storeCrossSigningKeys(e,this.crossSigningInfo.keys)})}async checkDeviceVerifications(e){let t=this.baseApis.cryptoCallbacks.shouldUpgradeDeviceVerifications;if(t){if(d.logger.info("Starting device verification upgrade for ".concat(e)),this.crossSigningInfo.keys.user_signing){let i=this.deviceList.getStoredCrossSigningForUser(e);if(i){let s=await this.checkForDeviceVerificationUpgrade(e,i);s&&(await t({users:{[e]:s}})).includes(e)&&await this.baseApis.setDeviceVerified(e,i.getId())}}d.logger.info("Finished device verification upgrade for ".concat(e))}}enableLazyLoading(){this.lazyLoadMembers=!0}registerEventHandlers(e){e.on(L.RoomMemberEvent.Membership,this.onMembership),e.on(B.ClientEvent.ToDeviceEvent,this.onToDeviceEvent),e.on(U.RoomEvent.Timeline,this.onTimelineEvent),e.on(V.MatrixEventEvent.Decrypted,this.onTimelineEvent)}start(){d.logger.warn("MatrixClient.crypto.start() is deprecated")}stop(){this.outgoingRoomKeyRequestManager.stop(),this.deviceList.stop(),this.dehydrationManager.stop(),this.backupManager.stop()}getDeviceEd25519Key(){return this.olmDevice.deviceEd25519Key}getDeviceCurve25519Key(){return this.olmDevice.deviceCurve25519Key}async getOwnDeviceKeys(){if(!this.olmDevice.deviceCurve25519Key)throw Error("Curve25519 key not yet created");if(!this.olmDevice.deviceEd25519Key)throw Error("Ed25519 key not yet created");return{ed25519:this.olmDevice.deviceEd25519Key,curve25519:this.olmDevice.deviceCurve25519Key}}setGlobalBlacklistUnverifiedDevices(e){this.globalBlacklistUnverifiedDevices=e}getGlobalBlacklistUnverifiedDevices(){return this.globalBlacklistUnverifiedDevices}uploadDeviceKeys(){let e={algorithms:this.supportedAlgorithms,device_id:this.deviceId,keys:this.deviceKeys,user_id:this.userId};return this.signObject(e).then(()=>this.baseApis.uploadKeysRequest({device_keys:e}))}getNeedsNewFallback(){return!!this.needsNewFallback}maybeUploadOneTimeKeys(){if(this.oneTimeKeyCheckInProgress)return;let e=Date.now();if(null!==this.lastOneTimeKeyCheck&&e-this.lastOneTimeKeyCheck<6e4)return;this.lastOneTimeKeyCheck=e;let t=Math.floor(this.olmDevice.maxNumberOfOneTimeKeys()/2),i=async e=>{for(;t>e||this.getNeedsNewFallback();){if(t>e){d.logger.info("generating oneTimeKeys");let i=Math.min(t-e,5);await this.olmDevice.generateOneTimeKeys(i)}if(this.getNeedsNewFallback()){let e=await this.olmDevice.getFallbackKey();e.curve25519&&0!=Object.keys(e.curve25519).length||(d.logger.info("generating fallback key"),this.fallbackCleanup&&(clearTimeout(this.fallbackCleanup),delete this.fallbackCleanup),await this.olmDevice.generateFallbackKey())}d.logger.info("calling uploadOneTimeKeys");let i=await this.uploadOneTimeKeys();if(i.one_time_key_counts&&i.one_time_key_counts.signed_curve25519)e=i.one_time_key_counts.signed_curve25519;else throw Error("response for uploading keys does not contain one_time_key_counts.signed_curve25519")}};this.oneTimeKeyCheckInProgress=!0,Promise.resolve().then(()=>void 0!==this.oneTimeKeyCount?Promise.resolve(this.oneTimeKeyCount):this.baseApis.uploadKeysRequest({}).then(e=>e.one_time_key_counts.signed_curve25519||0)).then(e=>i(e)).catch(e=>{d.logger.error("Error uploading one-time keys",e.stack||e)}).finally(()=>{this.oneTimeKeyCount=void 0,this.oneTimeKeyCheckInProgress=!1})}async uploadOneTimeKeys(){let e;let t=[];if(this.getNeedsNewFallback()){for(let[i,s]of(e={},Object.entries((await this.olmDevice.getFallbackKey()).curve25519))){let r={key:s,fallback:!0};e["signed_curve25519:"+i]=r,t.push(this.signObject(r))}this.needsNewFallback=!1}let i=await this.olmDevice.getOneTimeKeys(),s={};for(let e in i.curve25519)if(i.curve25519.hasOwnProperty(e)){let r={key:i.curve25519[e]};s["signed_curve25519:"+e]=r,t.push(this.signObject(r))}await Promise.all(t);let r={one_time_keys:s};e&&(r["org.matrix.msc2732.fallback_keys"]=e,r.fallback_keys=e);let o=await this.baseApis.uploadKeysRequest(r);return e&&(this.fallbackCleanup=setTimeout(()=>{delete this.fallbackCleanup,this.olmDevice.forgetOldFallbackKey()},36e5)),await this.olmDevice.markKeysAsPublished(),o}downloadKeys(e,t){return this.deviceList.downloadKeys(e,!!t)}getStoredDevicesForUser(e){return this.deviceList.getStoredDevicesForUser(e)}async getUserDeviceInfo(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=new Map,s=[];for(let t of e){let e=await this.getStoredDevicesForUser(t);if(e){let s=new Map(e.map(e=>[e.deviceId,(0,W.deviceInfoToDevice)(e,t)]));i.set(t,s)}else s.push(t)}return t&&s.length>0&&(await this.downloadKeys(s)).forEach((e,t)=>{let s=new Map;e.forEach((e,i)=>s.set(i,(0,W.deviceInfoToDevice)(e,t))),i.set(t,s)}),i}getStoredDevice(e,t){return this.deviceList.getStoredDevice(e,t)}saveDeviceList(e){return this.deviceList.saveIfDirty(e)}async setDeviceVerified(e,t){let i=!(arguments.length>2)||void 0===arguments[2]||arguments[2];await this.setDeviceVerification(e,t,i)}async crossSignDevice(e){await this.setDeviceVerified(this.userId,e,!0)}async setDeviceVerification(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5?arguments[5]:void 0,n=this.deviceList.getStoredCrossSigningForUser(e);if((null==n?void 0:n.getId())===t){if(null!==s||null!==r)throw Error("Cannot set blocked or known for a cross-signing key");if(!i)throw Error("Cannot set a cross-signing key as unverified");let a=o?Object.values(o)[0]:null;if(o&&(1!==Object.values(o).length||a!==n.getId()))throw Error("Key did not match expected value: expected ".concat(n.getId(),", got ").concat(a));if(this.crossSigningInfo.getId()||e!==this.crossSigningInfo.userId||(this.storeTrustedSelfKeys(n.keys),this.emit($.UserTrustStatusChanged,this.userId,this.checkUserTrust(e))),e===this.userId)return n;{d.logger.info("Master key "+n.getId()+" for "+e+" marked verified. Signing...");let i=await this.crossSigningInfo.signUser(n);if(i){let s=async r=>{let{shouldEmit:o=!1}=r;d.logger.info("Uploading signature for "+e+"...");let{failures:n}=await this.baseApis.uploadKeySignatures({[e]:{[t]:i}})||{};if(Object.keys(n||[]).length>0)throw o&&this.baseApis.emit($.KeySignatureUploadFailure,n,"setDeviceVerification",s),new O.KeySignatureUploadError("Key upload failed",{failures:n})};await s({shouldEmit:!0})}return i}}let a=this.deviceList.getRawStoredDevicesForUser(e);if(!a||!a[t])throw Error("Unknown device "+e+":"+t);let c=a[t],g=c.verified;if(i){if(o){for(let[e,t]of Object.entries(o))if(c.keys[e]!==t)throw Error("Key did not match expected value: expected ".concat(t,", got ").concat(c.keys[e]))}g=X.VERIFIED}else null!==i&&g==X.VERIFIED&&(g=X.UNVERIFIED);s?g=X.BLOCKED:null!==s&&g==X.BLOCKED&&(g=X.UNVERIFIED);let l=c.known;if(null!==r&&(l=r),(c.verified!==g||c.known!==l)&&(c.verified=g,c.known=l,this.deviceList.storeDevicesForUser(e,a),this.deviceList.saveIfDirty()),i&&e===this.userId){let i;if(d.logger.info("Own device "+t+" marked verified: signing"),this.checkDeviceTrust(e,t).isCrossSigningVerified()?d.logger.log("Own device ".concat(t," already cross-signing verified")):i=await this.crossSigningInfo.signDevice(e,v.DeviceInfo.fromStorage(c,t)),i){let s=async r=>{let{shouldEmit:o=!1}=r;d.logger.info("Uploading signature for "+t);let{failures:n}=await this.baseApis.uploadKeySignatures({[e]:{[t]:i}})||{};if(Object.keys(n||[]).length>0)throw o&&this.baseApis.emit($.KeySignatureUploadFailure,n,"setDeviceVerification",s),new O.KeySignatureUploadError("Key upload failed",{failures:n})};await s({shouldEmit:!0})}}let h=v.DeviceInfo.fromStorage(c,t);return this.emit($.DeviceVerificationChanged,e,t,h),h}findVerificationRequestDMInProgress(e,t){return this.inRoomVerificationRequests.findRequestInProgress(e,t)}getVerificationRequestsToDeviceInProgress(e){return this.toDeviceVerificationRequests.getRequestsInProgress(e)}requestVerificationDM(e,t){let i=this.inRoomVerificationRequests.findRequestInProgress(t);if(i)return Promise.resolve(i);let s=new E.InRoomChannel(this.baseApis,t,e);return this.requestVerificationWithChannel(e,s,this.inRoomVerificationRequests)}requestVerification(e,t){t||(t=Object.keys(this.deviceList.getRawStoredDevicesForUser(e)));let i=this.toDeviceVerificationRequests.findRequestInProgress(e,t);if(i)return Promise.resolve(i);let s=new T.ToDeviceChannel(this.baseApis,e,t,T.ToDeviceChannel.makeTransactionId());return this.requestVerificationWithChannel(e,s,this.toDeviceVerificationRequests)}requestOwnUserVerification(){return this.requestVerification(this.userId)}requestDeviceVerification(e,t){return this.requestVerification(e,[t])}async requestVerificationWithChannel(e,t,i){let s=new K.VerificationRequest(t,this.verificationMethods,this.baseApis);t.transactionId&&i.setRequestByChannel(t,s),await s.sendRequest();let r=i.getRequestByChannel(t);return r?s=r:(d.logger.log("Crypto: adding new request to "+"requestsByTxnId with id ".concat(t.transactionId," ").concat(t.roomId)),i.setRequestByChannel(t,s)),s}beginKeyVerification(e,t,i){let s,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(r){if(!(s=this.toDeviceVerificationRequests.getRequestBySenderAndTxnId(t,r)))throw Error("No request found for user ".concat(t," with ")+"transactionId ".concat(r))}else{r=T.ToDeviceChannel.makeTransactionId();let e=new T.ToDeviceChannel(this.baseApis,t,[i],r,i);s=new K.VerificationRequest(e,this.verificationMethods,this.baseApis),this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(t,r,s)}return s.beginKeyVerification(e,{userId:t,deviceId:i})}async legacyDeviceVerification(e,t,i){let s=T.ToDeviceChannel.makeTransactionId(),r=new T.ToDeviceChannel(this.baseApis,e,[t],s,t),o=new K.VerificationRequest(r,this.verificationMethods,this.baseApis);this.toDeviceVerificationRequests.setRequestBySenderAndTxnId(e,s,o);let n=o.beginKeyVerification(i,{userId:e,deviceId:t});return await Promise.race([n.verify(),o.waitFor(e=>e.started)]),o}async getOlmSessionsForUser(e){let t=this.getStoredDevicesForUser(e)||[],i={};for(let e of t){let t=e.getIdentityKey(),s=await this.olmDevice.getSessionInfoForDevice(t);i[e.deviceId]={deviceIdKey:t,sessions:s}}return i}getEventSenderDeviceInfo(e){let t=e.getSenderKey(),i=e.getWireContent().algorithm;if(!t||!i||e.isKeySourceUntrusted())return null;let s=this.deviceList.getDeviceByIdentityKey(i,t);if(null===s)return null;let r=e.getClaimedEd25519Key();return r?r!==s.getFingerprint()?(d.logger.warn("Event "+e.getId()+" claims ed25519 key "+r+" but sender device has key "+s.getFingerprint()),null):s:(d.logger.warn("Event "+e.getId()+" claims no ed25519 key: cannot verify sending device"),null)}getEventEncryptionInfo(e){var t,i;let s={};if(s.senderKey=null!==(t=e.getSenderKey())&&void 0!==t?t:void 0,s.algorithm=e.getWireContent().algorithm,!s.senderKey||!s.algorithm)return s.encrypted=!1,s;s.encrypted=!0,e.isKeySourceUntrusted()?s.authenticated=!1:s.authenticated=!0,s.sender=null!==(i=this.deviceList.getDeviceByIdentityKey(s.algorithm,s.senderKey))&&void 0!==i?i:void 0;let r=e.getClaimedEd25519Key();return r||(d.logger.warn("Event "+e.getId()+" claims no ed25519 key: cannot verify sending device"),s.mismatchedSender=!0),s.sender&&r!==s.sender.getFingerprint()&&(d.logger.warn("Event "+e.getId()+" claims ed25519 key "+r+"but sender device has key "+s.sender.getFingerprint()),s.mismatchedSender=!0),s}async getEncryptionInfoForEvent(e){let t=this.getEventEncryptionInfo(e);if(!t.encrypted)return null;let i=e.getSender();if(!i||t.mismatchedSender)return{shieldColour:G.EventShieldColour.RED,shieldReason:G.EventShieldReason.MISMATCHED_SENDER_KEY};if(!this.checkUserTrust(i).isCrossSigningVerified())return t.authenticated?{shieldColour:G.EventShieldColour.NONE,shieldReason:null}:{shieldColour:G.EventShieldColour.GREY,shieldReason:G.EventShieldReason.AUTHENTICITY_NOT_GUARANTEED};let s=i&&t.sender&&await this.getDeviceVerificationStatus(i,t.sender.deviceId);return s?s.isVerified()?t.authenticated?{shieldColour:G.EventShieldColour.NONE,shieldReason:null}:{shieldColour:G.EventShieldColour.GREY,shieldReason:G.EventShieldReason.AUTHENTICITY_NOT_GUARANTEED}:{shieldColour:G.EventShieldColour.RED,shieldReason:G.EventShieldReason.UNSIGNED_DEVICE}:{shieldColour:G.EventShieldColour.GREY,shieldReason:G.EventShieldReason.UNKNOWN_DEVICE}}forceDiscardSession(e){let t=this.roomEncryptors.get(e);if(void 0===t)throw Error("Room not encrypted");if(void 0===t.forceDiscardSession)throw Error("Room encryption algorithm doesn't support session discarding");return t.forceDiscardSession(),Promise.resolve()}async setRoomEncryption(e,t,i){let s=this.clientStore.getRoom(e);if(!s)throw Error("Unable to enable encryption tracking devices in unknown room ".concat(e));await this.setRoomEncryptionImpl(s,t),this.lazyLoadMembers||i||this.deviceList.refreshOutdatedDeviceLists()}async setRoomEncryptionImpl(e,t){let i=e.roomId;if(!t.algorithm){d.logger.log("Ignoring setRoomEncryption with no algorithm");return}let s=this.roomList.getRoomEncryption(i);if(s&&JSON.stringify(s)!=JSON.stringify(t)){d.logger.error("Ignoring m.room.encryption event which requests a change of config in "+i);return}if(this.roomEncryptors.get(i))return;let r=null;s||(r=this.roomList.setRoomEncryption(i,t));let o=p.ENCRYPTION_CLASSES.get(t.algorithm);if(!o)throw Error("Unable to encrypt with "+t.algorithm);let n=new o({userId:this.userId,deviceId:this.deviceId,crypto:this,olmDevice:this.olmDevice,baseApis:this.baseApis,roomId:i,config:t});if(this.roomEncryptors.set(i,n),r&&await r,d.logger.log("Enabling encryption in ".concat(i)),e.membersLoaded())await this.trackRoomDevicesImpl(e);else{let t=s=>{e.off(N.RoomStateEvent.Update,t),e.membersLoaded()&&this.trackRoomDevicesImpl(e).catch(e=>{d.logger.error("Error enabling device tracking in ".concat(i),e)})};e.on(N.RoomStateEvent.Update,t)}}trackRoomDevices(e){let t=this.clientStore.getRoom(e);if(!t)throw Error("Unable to start tracking devices in unknown room ".concat(e));return this.trackRoomDevicesImpl(t)}trackRoomDevicesImpl(e){let t=e.roomId,i=async()=>{this.roomEncryptors.has(t)&&(d.logger.log("Starting to track devices for room ".concat(t," ...")),(await e.getEncryptionTargetMembers()).forEach(e=>{this.deviceList.startTrackingDeviceList(e.userId)}))},s=this.roomDeviceTrackingState[t];return s||(s=i(),this.roomDeviceTrackingState[t]=s.catch(e=>{throw delete this.roomDeviceTrackingState[t],e})),s}ensureOlmSessionsForUsers(e,t){let i=new Map;for(let t of e){let e=[];for(let s of(i.set(t,e),this.getStoredDevicesForUser(t)||[]))s.getIdentityKey()!=this.olmDevice.deviceCurve25519Key&&s.verified!=X.BLOCKED&&e.push(s)}return u.ensureOlmSessionsForDevices(this.olmDevice,this.baseApis,i,t)}async exportRoomKeys(){let e=[];return await this.cryptoStore.doTxn("readonly",[I.IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS],t=>{this.cryptoStore.getAllEndToEndInboundGroupSessions(t,t=>{if(null===t)return;let i=this.olmDevice.exportInboundGroupSession(t.senderKey,t.sessionId,t.sessionData);delete i.first_known_index,i.algorithm=u.MEGOLM_ALGORITHM,e.push(i)})}),e}importRoomKeys(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=0,s=0,r=e.length;function o(){var e;null===(e=t.progressCallback)||void 0===e||e.call(t,{stage:"load_keys",successes:i,failures:s,total:r})}return Promise.all(e.map(e=>e.room_id&&e.algorithm?this.getRoomDecryptor(e.room_id,e.algorithm).importRoomKey(e,t).finally(()=>{i++,t.progressCallback&&o()}):(d.logger.warn("ignoring room key entry with missing fields",e),s++,t.progressCallback&&o(),null))).then()}countSessionsNeedingBackup(){return this.backupManager.countSessionsNeedingBackup()}prepareToEncrypt(e){let t=this.roomEncryptors.get(e.roomId);t&&t.prepareToEncrypt(e)}async encryptEvent(e,t){let i=e.getRoomId(),s=this.roomEncryptors.get(i);if(!s)throw Error("Room "+i+" was previously configured to use encryption, but is no longer. Perhaps the homeserver is hiding the configuration event.");await this.trackRoomDevicesImpl(t);let r=e.getContent(),o=r["m.relates_to"];o&&(r=Object.assign({},r),delete r["m.relates_to"]);let n=r["io.element.performance_metrics"];n&&(r=Object.assign({},r),delete r["io.element.performance_metrics"]);let a=await s.encryptMessage(t,e.getType(),r);o&&(a["m.relates_to"]=o),n&&(a["io.element.performance_metrics"]=n),e.makeEncrypted("m.room.encrypted",a,this.olmDevice.deviceCurve25519Key,this.olmDevice.deviceEd25519Key)}async decryptEvent(e){if(e.isRedacted()){let t=new V.MatrixEvent(function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?J(Object(i),!0).forEach(function(t){(0,n.default)(e,t,i[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):J(Object(i)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))})}return e}({room_id:e.getRoomId()},e.getUnsigned().redacted_because)),i=e.getUnsigned().redacted_because;if(t.isEncrypted())try{i=(await this.decryptEvent(t)).clearEvent}catch(e){d.logger.warn("Decryption of redaction failed. Falling back to unencrypted event.",e)}return{clearEvent:{room_id:e.getRoomId(),type:"m.room.message",content:{},unsigned:{redacted_because:i}}}}{let t=e.getWireContent();return this.getRoomDecryptor(e.getRoomId(),t.algorithm).decryptEvent(e)}}async processDeviceLists(e){await this.evalDeviceListChanges(e)}requestRoomKey(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return this.outgoingRoomKeyRequestManager.queueRoomKeyRequest(e,t,i).then(()=>{this.sendKeyRequestsImmediately&&this.outgoingRoomKeyRequestManager.sendQueuedRequests()}).catch(e=>{d.logger.error("Error requesting key for event",e)})}cancelRoomKeyRequest(e){this.outgoingRoomKeyRequestManager.cancelRoomKeyRequest(e).catch(e=>{d.logger.warn("Error clearing pending room key requests",e)})}async cancelAndResendAllOutgoingKeyRequests(){await this.outgoingRoomKeyRequestManager.cancelAndResendAllOutgoingRequests()}async onCryptoEvent(e,t){let i=t.getContent();await this.setRoomEncryptionImpl(e,i)}async onSyncWillProcess(e){e.oldSyncToken||(d.logger.log("Initial sync performed - resetting device tracking state"),this.deviceList.stopTrackingAllDeviceLists(),this.deviceList.startTrackingDeviceList(this.userId),this.roomDeviceTrackingState={}),this.sendKeyRequestsImmediately=!1}async onSyncCompleted(e){var t;this.deviceList.setSyncToken(null!==(t=e.nextSyncToken)&&void 0!==t?t:null),this.deviceList.saveIfDirty(),this.deviceList.startTrackingDeviceList(this.userId),this.deviceList.refreshOutdatedDeviceLists(),e.catchingUp||(this.maybeUploadOneTimeKeys(),this.processReceivedRoomKeyRequests(),this.outgoingRoomKeyRequestManager.sendQueuedRequests(),this.sendKeyRequestsImmediately=!0)}async evalDeviceListChanges(e){if(Array.isArray(null==e?void 0:e.changed)&&e.changed.forEach(e=>{this.deviceList.invalidateUserDeviceList(e)}),Array.isArray(null==e?void 0:e.left)&&e.left.length){let t=new Set(await this.getTrackedE2eUsers());e.left.forEach(e=>{t.has(e)||this.deviceList.stopTrackingDeviceList(e)})}}async getTrackedE2eUsers(){let e=[];for(let t of this.getTrackedE2eRooms())for(let i of(await t.getEncryptionTargetMembers()))e.push(i.userId);return e}getTrackedE2eRooms(){return this.clientStore.getRooms().filter(e=>{if(!this.roomEncryptors.get(e.roomId)||!this.roomDeviceTrackingState[e.roomId])return!1;let t=e.getMyMembership();return"join"===t||"invite"===t})}async encryptAndSendToDevices(e,t){let i={eventType:g.EventType.RoomMessageEncrypted,batch:[]};try{await Promise.all(e.map(async e=>{let{userId:s,deviceInfo:r}=e,o=r.deviceId,n={algorithm:u.OLM_ALGORITHM,sender_key:this.olmDevice.deviceCurve25519Key,ciphertext:{},[g.ToDeviceMessageId]:(0,c.v4)()};i.batch.push({userId:s,deviceId:o,payload:n}),await u.ensureOlmSessionsForDevices(this.olmDevice,this.baseApis,new Map([[s,[r]]])),await u.encryptMessageForDevice(n.ciphertext,this.userId,this.deviceId,this.olmDevice,s,r,t)})),i.batch=i.batch.filter(e=>Object.keys(e.payload.ciphertext).length>0||(d.logger.log("No ciphertext for device ".concat(e.userId,":").concat(e.deviceId,": pruning")),!1));try{await this.baseApis.queueToDevice(i)}catch(e){throw d.logger.error("sendToDevice failed",e),e}}catch(e){throw d.logger.error("encryptAndSendToDevices promises failed",e),e}}async preprocessToDeviceMessages(e){return e.filter(e=>{var t;return!!(e.type!==g.EventType.RoomMessageEncrypted||["m.olm.v1.curve25519-aes-sha2"].includes(null===(t=e.content)||void 0===t?void 0:t.algorithm))||(d.logger.log("Ignoring invalid encrypted to-device event from "+e.sender),!1)})}updateOneTimeKeyCount(e){if(isFinite(e))this.oneTimeKeyCount=e;else throw TypeError("Parameter for updateOneTimeKeyCount has to be a number")}processKeyCounts(e,t){return void 0!==e&&this.updateOneTimeKeyCount(e.signed_curve25519||0),void 0!==t&&(this.needsNewFallback=!t.includes("signed_curve25519")),Promise.resolve()}onRoomKeyEvent(e){let t=e.getContent();if(!t.room_id||!t.algorithm){d.logger.error("key event is missing fields");return}this.backupManager.checkedForBackup||this.backupManager.checkAndStart(),this.getRoomDecryptor(t.room_id,t.algorithm).onRoomKeyEvent(e)}onRoomKeyWithheldEvent(e){let t=e.getContent();if("m.no_olm"!==t.code&&(!t.room_id||!t.session_id)||!t.algorithm||!t.sender_key){d.logger.error("key withheld event is missing fields");return}d.logger.info("Got room key withheld event from ".concat(e.getSender()," ")+"for ".concat(t.algorithm," session ").concat(t.sender_key,"|").concat(t.session_id," ")+"in room ".concat(t.room_id," with code ").concat(t.code," (").concat(t.reason,")"));let i=this.getRoomDecryptor(t.room_id,t.algorithm);if(i.onRoomKeyWithheldEvent&&i.onRoomKeyWithheldEvent(e),!t.room_id)for(let e of this.getRoomDecryptors(t.algorithm))e.retryDecryptionFromSender(t.sender_key)}onKeyVerificationMessage(e){T.ToDeviceChannel.validateEvent(e,this.baseApis)&&this.handleVerificationEvent(e,this.toDeviceVerificationRequests,e=>{if(!T.ToDeviceChannel.canCreateRequest(T.ToDeviceChannel.getEventType(e)))return;let t=e.getContent(),i=t&&t.from_device;if(!i)return;let s=e.getSender(),r=new T.ToDeviceChannel(this.baseApis,s,[i]);return new K.VerificationRequest(r,this.verificationMethods,this.baseApis)})}async handleVerificationEvent(e,t,i){let s=!(arguments.length>3)||void 0===arguments[3]||arguments[3];if(e.isSending()&&e.status!=V.EventStatus.SENT){let t,i;try{await new Promise((s,r)=>{t=s,i=()=>{e.status==V.EventStatus.CANCELLED&&r(Error("Event status set to CANCELLED."))},e.once(V.MatrixEventEvent.LocalEventIdReplaced,t),e.on(V.MatrixEventEvent.Status,i)})}catch(e){d.logger.error("error while waiting for the verification event to be sent: ",e);return}finally{e.removeListener(V.MatrixEventEvent.LocalEventIdReplaced,t),e.removeListener(V.MatrixEventEvent.Status,i)}}let r=t.getRequest(e),o=!1;if(!r){if(!(r=i(e))){d.logger.log("Crypto: could not find VerificationRequest for "+"".concat(e.getType(),", and could not create one, so ignoring."));return}o=!0,t.setRequest(e,r)}e.setVerificationRequest(r);try{await r.channel.handleEvent(e,r,s)}catch(e){d.logger.error("error while handling verification event",e)}!o||r.initiatedByMe||r.invalid||r.observeOnly||(this.baseApis.emit($.VerificationRequest,r),this.baseApis.emit($.VerificationRequestReceived,r))}async onToDeviceBadEncrypted(e){let t=e.getWireContent(),i=e.getSender(),s=t.algorithm,r=t.sender_key;this.baseApis.emit(B.ClientEvent.UndecryptableToDeviceEvent,e);let o=()=>{for(let e of this.getRoomDecryptors(u.MEGOLM_ALGORITHM))e.retryDecryptionFromSender(r)};if(void 0===i||void 0===r||void 0===r)return;let n=this.forceNewSessionRetryTime.getOrCreate(i),a=n.getOrCreate(r);if(a>Date.now()){d.logger.debug("New session already forced with device ".concat(i,":").concat(r,": ")+"not forcing another until at least ".concat(new Date(a).toUTCString())),await this.olmDevice.recordSessionProblem(r,"wedged",!0),o();return}n.set(r,Date.now()+3e5);let l=this.deviceList.getDeviceByIdentityKey(s,r);if(!l&&(await this.downloadKeys([i],!1),!(l=this.deviceList.getDeviceByIdentityKey(s,r)))){d.logger.info("Couldn't find device for identity key "+r+": not re-establishing session"),await this.olmDevice.recordSessionProblem(r,"wedged",!1),o();return}let h=new Map([[i,[l]]]);await u.ensureOlmSessionsForDevices(this.olmDevice,this.baseApis,h,!0),n.set(r,Date.now()+36e5);let y={algorithm:u.OLM_ALGORITHM,sender_key:this.olmDevice.deviceCurve25519Key,ciphertext:{},[g.ToDeviceMessageId]:(0,c.v4)()};for(let e of(await u.encryptMessageForDevice(y.ciphertext,this.userId,this.deviceId,this.olmDevice,i,l,{type:"m.dummy"}),await this.olmDevice.recordSessionProblem(r,"wedged",!0),o(),await this.baseApis.sendToDevice("m.room.encrypted",new Map([[i,new Map([[l.deviceId,y]])]])),await this.outgoingRoomKeyRequestManager.getOutgoingSentRoomKeyRequest(i,l.deviceId)))this.requestRoomKey(e.requestBody,e.recipients,!0)}onRoomMembership(e,t,i){let s=t.roomId,r=this.roomEncryptors.get(s);if(r){if(s in this.roomDeviceTrackingState){var o;"join"==t.membership?(d.logger.log("Join event for "+t.userId+" in "+s),this.deviceList.startTrackingDeviceList(t.userId)):"invite"==t.membership&&null!==(o=this.clientStore.getRoom(s))&&void 0!==o&&o.shouldEncryptForInvitedMembers()&&(d.logger.log("Invite event for "+t.userId+" in "+s),this.deviceList.startTrackingDeviceList(t.userId))}r.onRoomMembership(e,t,i)}}onRoomKeyRequestEvent(e){let t=e.getContent();if("request"===t.action){let t=new ei(e);this.receivedRoomKeyRequests.push(t)}else if("request_cancellation"===t.action){let t=new es(e);this.receivedRoomKeyRequestCancellations.push(t)}}async processReceivedRoomKeyRequests(){if(!this.processingRoomKeyRequests){this.processingRoomKeyRequests=!0;try{let e=this.receivedRoomKeyRequests;this.receivedRoomKeyRequests=[];let t=this.receivedRoomKeyRequestCancellations;this.receivedRoomKeyRequestCancellations=[],await Promise.all(e.map(e=>this.processReceivedRoomKeyRequest(e))),await Promise.all(t.map(e=>this.processReceivedRoomKeyRequestCancellation(e)))}catch(e){d.logger.error("Error processing room key requsts: ".concat(e))}finally{this.processingRoomKeyRequests=!1}}}async processReceivedRoomKeyRequest(e){let t=e.userId,i=e.deviceId,s=e.requestBody,r=s.room_id,o=s.algorithm;if(d.logger.log("m.room_key_request from ".concat(t,":").concat(i)+" for ".concat(r," / ").concat(s.session_id," (id ").concat(e.requestId,")")),t!==this.userId){if(!this.roomEncryptors.get(r)){d.logger.debug("room key request for unencrypted room ".concat(r));return}let e=this.roomEncryptors.get(r),o=this.deviceList.getStoredDevice(t,i);if(!o){d.logger.debug("Ignoring keyshare for unknown device ".concat(t,":").concat(i));return}try{await e.reshareKeyWithDevice(s.sender_key,s.session_id,t,o)}catch(e){d.logger.warn("Failed to re-share keys for session "+s.session_id+" with device "+t+":"+o.deviceId,e)}return}if(i===this.deviceId){d.logger.log("Ignoring room key request from ourselves");return}if(!this.roomDecryptors.has(r)){d.logger.log("room key request for unencrypted room ".concat(r));return}let n=this.roomDecryptors.get(r).get(o);if(!n){d.logger.log("room key request for unknown alg ".concat(o," in room ").concat(r));return}if(!await n.hasKeysForKeyRequest(e)){d.logger.log("room key request for unknown session ".concat(r," / ")+s.session_id);return}if(e.share=()=>{n.shareKeysWithDevice(e)},this.checkDeviceTrust(t,i).isVerified()){d.logger.log("device is already verified: sharing keys"),e.share();return}this.emit($.RoomKeyRequest,e)}async processReceivedRoomKeyRequestCancellation(e){d.logger.log("m.room_key_request cancellation for ".concat(e.userId,":")+"".concat(e.deviceId," (id ").concat(e.requestId,")")),this.emit($.RoomKeyRequestCancellation,e)}getRoomDecryptor(e,t){let i,s;if(e&&((i=this.roomDecryptors.get(e))||(i=new Map,this.roomDecryptors.set(e,i)),s=i.get(t)))return s;let r=p.DECRYPTION_CLASSES.get(t);if(!r)throw new p.DecryptionError("UNKNOWN_ENCRYPTION_ALGORITHM",'Unknown encryption algorithm "'+t+'".');return s=new r({userId:this.userId,crypto:this,olmDevice:this.olmDevice,baseApis:this.baseApis,roomId:null!=e?e:void 0}),i&&i.set(t,s),s}getRoomDecryptors(e){let t=[];for(let i of this.roomDecryptors.values())i.has(e)&&t.push(i.get(e));return t}async signObject(e){let t=new Map(Object.entries(e.signatures||{})),i=e.unsigned;delete e.signatures,delete e.unsigned;let s=t.get(this.userId)||{};t.set(this.userId,s),s["ed25519:"+this.deviceId]=await this.olmDevice.sign(a.default.stringify(e)),e.signatures=(0,j.recursiveMapToObject)(t),void 0!==i&&(e.unsigned=i)}isRoomEncrypted(e){return this.roomList.isRoomEncrypted(e)}async isEncryptionEnabledInRoom(e){return this.isRoomEncrypted(e)}getRoomEncryption(e){return this.roomList.getRoomEncryption(e)}constructor(e,t,i,s,r,o){var a;if(super(),a=this,(0,n.default)(this,"trustCrossSignedDevices",!0),(0,n.default)(this,"lastOneTimeKeyCheck",null),(0,n.default)(this,"oneTimeKeyCheckInProgress",!1),(0,n.default)(this,"roomEncryptors",new Map),(0,n.default)(this,"roomDecryptors",new Map),(0,n.default)(this,"deviceKeys",{}),(0,n.default)(this,"globalBlacklistUnverifiedDevices",!1),(0,n.default)(this,"globalErrorOnUnknownDevices",!0),(0,n.default)(this,"receivedRoomKeyRequests",[]),(0,n.default)(this,"receivedRoomKeyRequestCancellations",[]),(0,n.default)(this,"processingRoomKeyRequests",!1),(0,n.default)(this,"lazyLoadMembers",!1),(0,n.default)(this,"roomDeviceTrackingState",{}),(0,n.default)(this,"forceNewSessionRetryTime",new j.MapWithDefault(()=>new j.MapWithDefault(()=>0))),(0,n.default)(this,"sendKeyRequestsImmediately",!1),(0,n.default)(this,"onDeviceListUserCrossSigningUpdated",async e=>{if(e===this.userId){let t=this.deviceList.getStoredCrossSigningForUser(e),i=t?t.getId():null,s=this.crossSigningInfo.getId();s&&i&&!(s!==i)?await this.checkOwnCrossSigningTrust():(this.storeTrustedSelfKeys(null),this.emit($.KeysChanged,{}),this.emit($.UserTrustStatusChanged,this.userId,this.checkUserTrust(e)))}else{await this.checkDeviceVerifications(e);let t=this.deviceList.getStoredCrossSigningForUser(e);t&&(t.updateCrossSigningVerifiedBefore(this.checkUserTrust(e).isCrossSigningVerified()),this.deviceList.setRawStoredCrossSigningForUser(e,t.toStorage())),this.emit($.UserTrustStatusChanged,e,this.checkUserTrust(e))}}),(0,n.default)(this,"onMembership",(e,t,i)=>{try{this.onRoomMembership(e,t,i)}catch(e){d.logger.error("Error handling membership change:",e)}}),(0,n.default)(this,"onToDeviceEvent",e=>{try{d.logger.log("received to-device ".concat(e.getType()," from: ")+"".concat(e.getSender()," id: ").concat(e.getContent()[g.ToDeviceMessageId])),"m.room_key"==e.getType()||"m.forwarded_room_key"==e.getType()?this.onRoomKeyEvent(e):"m.room_key_request"==e.getType()?this.onRoomKeyRequestEvent(e):"m.secret.request"===e.getType()?this.secretStorage.onRequestReceived(e):"m.secret.send"===e.getType()?this.secretStorage.onSecretReceived(e):"m.room_key.withheld"===e.getType()?this.onRoomKeyWithheldEvent(e):e.getContent().transaction_id?this.onKeyVerificationMessage(e):"m.bad.encrypted"===e.getContent().msgtype?this.onToDeviceBadEncrypted(e):(e.isBeingDecrypted()||e.shouldAttemptDecryption())&&(e.isBeingDecrypted()||e.attemptDecryption(this),e.once(V.MatrixEventEvent.Decrypted,e=>{this.onToDeviceEvent(e)}))}catch(e){d.logger.error("Error handling toDeviceEvent:",e)}}),(0,n.default)(this,"onTimelineEvent",function(e,t,i,s){let{liveEvent:r=!0}=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};E.InRoomChannel.validateEvent(e,a.baseApis)&&a.handleVerificationEvent(e,a.inRoomVerificationRequests,e=>{let t=new E.InRoomChannel(a.baseApis,e.getRoomId());return new K.VerificationRequest(t,a.verificationMethods,a.baseApis)},r)}),this.baseApis=e,this.userId=t,this.deviceId=i,this.clientStore=s,this.cryptoStore=r,d.logger.debug("Crypto: initialising roomlist..."),this.roomList=new F.RoomList(r),this.reEmitter=new l.TypedReEmitter(this),o)for(let e of(this.verificationMethods=new Map,o))"string"==typeof e?Z[e]&&this.verificationMethods.set(e,Z[e]):e.NAME?this.verificationMethods.set(e.NAME,e):d.logger.warn("Excluding unknown verification method ".concat(e));else this.verificationMethods=new Map(Object.entries(Z));this.backupManager=new M.BackupManager(e,async()=>{let e=await this.getSessionBackupPrivateKey();if(e)return e;let t=await this.secretStorage.get("m.megolm_backup.v1");if(t){let e=et(t);if(e){let t=await this.secretStorage.getKey();await this.secretStorage.store("m.megolm_backup.v1",e,[t[0]])}return(0,Y.decodeBase64)(e||t)}if(this.baseApis.cryptoCallbacks&&this.baseApis.cryptoCallbacks.getBackupKey)return this.baseApis.cryptoCallbacks.getBackupKey();throw Error("Unable to get private key")}),this.olmDevice=new h.OlmDevice(r),this.deviceList=new y.DeviceList(e,r,this.olmDevice),this.deviceList.on($.UserCrossSigningUpdated,this.onDeviceListUserCrossSigningUpdated),this.reEmitter.reEmit(this.deviceList,[$.DevicesUpdated,$.WillUpdateDevices]),this.supportedAlgorithms=Array.from(p.DECRYPTION_CLASSES.keys()),this.outgoingRoomKeyRequestManager=new w.OutgoingRoomKeyRequestManager(e,this.deviceId,this.cryptoStore),this.toDeviceVerificationRequests=new T.ToDeviceRequests,this.inRoomVerificationRequests=new E.InRoomRequests;let c=this.baseApis.cryptoCallbacks||{},u=(0,f.createCryptoStoreCacheCallbacks)(r,this.olmDevice);this.crossSigningInfo=new f.CrossSigningInfo(t,c,u),this.secretStorage=new S.SecretStorage(e,c,e),this.dehydrationManager=new A.DehydrationManager(this),!c.getCrossSigningKey&&c.getSecretStorageKey&&(c.getCrossSigningKey=async e=>f.CrossSigningInfo.getFromSecretStorage(e,this.secretStorage))}}function et(e){if("string"!=typeof e||0>e.indexOf(","))return null;let t=Uint8Array.from(e.split(","),e=>parseInt(e));return(0,Y.encodeBase64)(t)}t.Crypto=ee;class ei{constructor(e){let t=e.getContent();this.userId=e.getSender(),this.deviceId=t.requesting_device_id,this.requestId=t.request_id,this.requestBody=t.body||{},this.share=()=>{throw Error("don't know how to share keys for this request yet")}}}t.IncomingRoomKeyRequest=ei;class es{constructor(e){let t=e.getContent();this.userId=e.getSender(),this.deviceId=t.requesting_device_id,this.requestId=t.request_id}}}}]);